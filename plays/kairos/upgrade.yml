---
- hosts: kairos
  gather_facts: false
  order: sorted
  tasks:
    - name: Ensure configuration is up-to-date
      ansible.builtin.template:
        dest: /oem/90_custom.yaml
        src: templates/config.yml.j2
      become: yes
      register: config
      vars:
        host: "{{ inventory_hostname }}"
    # If the config changes, including files that should no longer exist, we want to make sure the new config is what applies.
    - name: Remove old network files
      block:
        - name: Collect all network configuration files
          ansible.builtin.find:
            paths: /etc/systemd/network/
          register: collected_network_files
        - name: Remove all collected network files
          ansible.builtin.file:
            path: "{{ item.path }}"
            state: absent
          become: yes
          loop: "{{ collected_network_files.files }}"
          loop_control:
            label: "{{ item.path }}"
      when: config.changed
    - name: Read in current version
      ansible.builtin.slurp:
        src: /etc/os-release
      register: osreleasefile
    - name: Extract current version
      ansible.builtin.set_fact:
        os_release: "{{ osreleasefile['content'] | b64decode | regex_findall('^KAIROS_VERSION_ID=\"(.*)\"$', multiline=True) | last }}"
    - name: Print os version
      ansible.builtin.debug:
        var: os_release
    - name: Install update
      ansible.builtin.command:
        argv:
          - kairos-agent
          - upgrade
          # v1.6.1-k3sv1.26.1+k3s1 => v1.6.1-k3sv1.26.1-k3s1
          - "{{ kairos_version | replace('+', '-') }}"
      become: yes
      when: os_release != kairos_version
    - name: Note if the host needs to be rebooted
      ansible.builtin.set_fact:
        reboot_required: "{{ os_release != kairos_version or config.changed }}"
    - name: Schedule Drain and Reboot
      ansible.builtin.add_host:
        name: "{{ item }}"
        group: ToReboot
      changed_when: no
      delegate_to: localhost
      loop: "{{ ansible_play_batch }}"
      when: hostvars[item].reboot_required
  vars:
    # renovate: depName=quay.io/kairos/kairos-ubuntu-22-lts
    kairos_version: "v2.3.1-k3sv1.26.6+k3s1"

- name: Serially drain and reboot hosts that need to be rebooted
  hosts: ToReboot
  gather_facts: no
  order: sorted
  serial:
    - 1 # This will always be the control plane node.
    - 1 # This will be the first control plane & worker node.
    - 3 # The remaining control plane & worker node plus any worker nodes in chunks of three.
  strategy: free
  tasks:
    # TODO(sdwilsh): This does not work today because we need to be able to select specific pods.  See
    #                https://github.com/ansible-collections/kubernetes.core/issues/474
    # - name: Drain
    #   kubernetes.core.k8s_drain:
    #     delete_options:
    #       delete_emptydir_data: yes
    #       force: yes
    #       ignore_daemonsets: yes
    #     name: "{{ inventory_hostname_short }}"
    #     state: drain
    #   delegate_to: localhost
    - name: Drain
      ansible.builtin.shell:
        cmd: "kubectl drain {{ inventory_hostname_short }} --ignore-daemonsets --delete-emptydir-data --force --pod-selector='{{ pod_selectors | join(',') }}' --kubeconfig ~/.kube/config"
      delegate_to: localhost
      vars:
        pod_selectors:
          - app!=csi-attacher
          - app!=csi-provisioner
          - longhorn.io/instance-manager-type!=engine
          - longhorn.io/instance-manager-type!=replica
    - name: Reboot
      ansible.builtin.reboot:
        pre_reboot_delay: 60 # seconds
        connect_timeout: 240 # seconds
        test_command: "{{ reboot_test_command }}"
      become: yes
    - name: Uncordon
      kubernetes.core.k8s_drain:
        name: "{{ inventory_hostname_short }}"
        state: uncordon
      delegate_to: localhost
